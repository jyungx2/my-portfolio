---
title: ‘유랑마켓’
date: '2025-03-21'
tags: ['next js', 'tailwind']
draft: false
summary: 'How to derive the OLS Estimator with matrix notation and a tour of math typesetting using markdown with the help of KaTeX.'
---

## | 해외 거주 한인 대상 중고거래 및 커뮤니티 플랫폼

**🗓️ 기간:** 2025.03.24 ~  
**🛠️ 사용 기술:** HTML5, CSS, TailwindCSS, JavaScript, React, Next.js, Zustand, MongoDB, Firebase  
**💐 번들링 도구:** Webpack 5

- **구현 방식** : Next.js(Page Router) 기반 SSG + SSR + CSR을 혼합 적용한 풀스택 플랫폼
- **프로젝트 개요** : 워킹홀리데이 기간 중 겪었던 불편함을 바탕으로, 해외에 거주하는 한인들이 **쉽고 안전하게 중고거래 및 정보 교류**를 할 수 있도록 직접 기획하고 개발하게 되었습니다.

**🌿 깃허브:** [move to github](https://github.com/jyungx2/Next-urang-market)  
**🖥️ 배포 도구:** Vercel [move to site](https://next-urang-market.vercel.app/)

---

## 핵심 기능 구현

- **NextAuth.js + JWT 기반의 stateless 인증 구조 구현:**  
   사용자 정보 보호와 인증 상태 유지를 위해 JWT를 기반으로 한 세션/토큰 인증 흐름 설계 및 적용
- **Cloudinary API를 활용한 이미지 업로드 API 구축:**  
   프로필 및 게시글 이미지를 클라우드에 저장하고 secure URL을 반환하는 API 개발
  (\*base64 방식 대비 전송량 부담을 줄이고 확장성이 뛰어난 구조로 설계)
- **카카오 법정동 데이터를 MongoDB에 저장 및 검색 API 구현:**  
   사용자 입력에 따라 주소를 검색할 수 있는 API 및 연동 컴포넌트 개발 → **실시간 위치 검색 기능 제공**
- **브라우저 내장 Geolocation API + Kakao 역지오코딩 API 연동:**  
   현재 위치 좌표 기반으로 **법정동 주소 및 지역코드 자동 설정 기능** 구현
- **Redis + CoolSMS 기반 전화번호 인증 API 개발:**  
   CoolSMS API를 활용해 인증번호 발급(`/api/auth/send-code.js`) 및 검증(`/api/auth/verify-code.js`)로직을 구현하고, 로그인 절차와 연동  
   (\*추후 Firebase Authentication 기반 인증 시스템으로 전환 예정)
- **[Socket.io](http://Socket.io) 기반 실시간 채팅 기능 구현:**
  - 서버에 메시지가 저장되며 `_id`가 부여되기까지의 지연을 고려해, 프론트엔드에서는 `uuid`를 활용한 임시 `localId`를 생성해 UI에 즉시 반영함으로써 **UX 향상**
  - 이후 서버 응답으로 받은 메시지를 `localId` 기준으로 교체하여 최종 데이터와 동기화 처리  
    → 배포 완료 후, 구매자와 판매자 계정으로 동시 접속하여 실시간 채팅 정상 동작 테스트 예정

---

## 트러블슈팅

### 📌 구현 배경 및 해결 전략

중고마켓 커뮤니티 목록과 중고물품 목록에서, 각 게시글에 대해 사용자가 “좋아요/싫어요”를 눌렀는지 또는 위시리스트에 추가했는지를 판별해야 했습니다.
이를 위해 초기에는 API Routes에서 게시글 목록을 불러온 뒤, 유저의 likes, dislikes, wishlist 배열을 순회하며 includes() 메소드를 사용해 해당 게시글의 ID가 포함되어 있는지를 매번 확인하는 방식으로 구현하였습니다.

```js:api/posts/index.js
// 좋아요/싫어요 "배열" 생성
const likesArr = (user.likes ?? []).map(String);
const dislikesArr = (user.dislikes ?? []).map(String);

// 게시글에 userHasLiked / userHasDisliked 계산해서 붙이기
const postsWithUserStatus = documents.map((post) => {
  const id = String(post._id);
  return {
    ...post,
    userHasLiked: likesArr.includes(id),       // O(L)
    userHasDisliked: dislikesArr.includes(id), // O(L)
  };
});
```

### 📌 어떤 고민이 있었는지?

이 방식은 소규모 데이터에서는 문제없이 동작했으나, 데이터가 많아질수록 성능 저하가 두드러졌습니다. 실제로 게시글과 사용자 데이터가 일정 규모를 넘어가자 목록 API 응답 지연과 클라이언트 렌더링 지연이 동시에 발생하였고, 체감 속도가 눈에 띄게 떨어졌습니다.

문제의 원인을 살펴보니, 배열에서 “includes()”를 사용할 경우 특정 요소가 존재하는지를 확인하기 위해 매번 배열의 처음부터 끝까지 순차 탐색을 수행하게 되어 시간복잡도가 O(n)에 해당한다는 점이 성능 저하의 핵심 요인이었습니다.

### 📌 어떻게 해결했는지?

문제를 해결하기 위해 자료구조의 선택이 성능에 큰 영향을 준다는 점에 주목했습니다.

시간복잡도를 표현할 때에는 일반적으로 빅 오 표기법(Big O notation)을 사용하는데, 이는 입력 크기 *n*이 무한히 커질 때 실행 시간이 증가하는 추세를 점근적 상한으로 나타낸 것입니다.

여기서 **점근적 상한**이란, 입력하는 n이 무한대로 커진다고 생각했을 때, 일반적으로 n에 따라 실행시간도 점점 계속해서 증가할 것입니다. 하지만 **실행시간이 증가하는 데에도 한계**가 있는데, 이 한계를 **_점근적 상한이라고 부릅니다._** 즉, 실제 실행 시간이 경우에 따라 조금 더 빠를 수도 있지만, 최악의 경우를 기준으로 했을 때 반드시 넘지 못하는 시간 증가의 한계선을 수학적으로 표현한 개념입니다.

배열에서 `includes()` 메소드를 사용할 경우, 특정 데이터의 존재 여부를 확인하기 위해 앞에서부터 끝까지 순차적으로 탐색해야 합니다. 이때 최악의 경우에는 n개의 요소를 모두 검사해야 하므로, 실행 시간은 입력 크기 n에 비례하여 증가하게 됩니다. 이러한 성능을 빅 오 표기법(점근적 상한)으로 표현하면 **O(n)**, 즉 선형시간 복잡도를 갖습니다.

반면 `Set`은 내부적으로 해시테이블을 기반으로 동작합니다. 해시 함수가 곧바로 해당 요소의 주소를 찾아가기 때문에, 입력 크기와 상관없이 일정한 시간 내에 탐색이 가능합니다. 이러한 경우 실행 시간은 데이터가 아무리 많아져도 일정한 상한에 머물게 되고, 이를 빅 오 표기법으로 표현하면 **O(1)**, 즉 상수시간 복잡도를 갖습니다.

다시 말해 배열은 원하는 인덱스를 알고 있을 때는 O(1)로 접근할 수 있지만, 특정 데이터의 존재 여부를 확인하는 연산에서는 O(n)의 시간복잡도를 가집니다. 반면 `Set`은 내부적으로 해시테이블 기반으로 구현되어 있어, 요소의 존재 여부를 확인하는 연산에서 기대 시간복잡도가 O(1)에 해당합니다.

따라서, 유저의 `likes`, `dislikes`, `wishlist` 배열을 API 응답 단계에서 모두 `Set`으로 변환한 뒤, 각 게시글에 대해 `set.has(id)`로 존재 여부를 확인하도록 리팩토링하였습니다. 그 결과, 데이터가 많아져도 일정한 속도로 결과를 반환할 수 있었고, API 응답 지연과 클라이언트 렌더링 지연 문제를 동시에 해소할 수 있었습니다.

- `Array.prototype.includes()` → **O(n)**: 배열을 앞에서부터 끝까지 훑음
- `Set.prototype.has()` → **O(1)** 기대: 해시 조회(주소 찾아가기)에 해당'

```js:api/posts/index.js
// 좋아요/싫어요 Set 생성
const likeSet = new Set((user.likes ?? []).map(String));
const dislikeSet = new Set((user.dislikes ?? []).map(String));

// 각 게시글에 userHasLiked / userHasDisliked 계산해서 붙이기
const postsWithUserStatus = documents.map((post) => {
  const id = String(post._id);
  return {
    ...post,
    userHasLiked: likeSet.has(id),       // O(1) 기대
    userHasDisliked: dislikeSet.has(id), // O(1) 기대
  };
});
```

### 📌 무엇을 배웠는지?

- 시간복잡도의 개념과 이를 빅 오(Big O) 표기법으로 나타내는 방법을 명확히 이해했습니다.
- 배열과 Set의 시간복잡도를 비교하며, **특정 데이터의 존재 여부를 확인하는 연산에는 Set이 훨씬 효율적**임을 학습했습니다.
- 해시테이블 기반 자료구조는 속도가 빠른 만큼 메모리 공간을 더 많이 차지하긴 하지만, 순차 탐색을 수행하는 배열보다 일반적으로 우수한 성능을 제공한다는 점을 확인했습니다.
- 기능을 구현할 때는 단순히 동작 가능 여부뿐 아니라, 데이터 규모가 커졌을 때의 성능까지 고려하여 **자료구조를 적절히 선택하는 것이 중요**하다는 점을 배웠습니다.

### 현재 미구현 기능 (추후 개발 예정)

- 로그인 시 국가 설정 기능
- 메인 홈 페이지 UI 및 콘텐츠 구성
- 알림 기능
- 회원가입/로그인 시 인증 방식 리팩토링 예정
