---
title: 유랑마켓
date: '2025-03-21'
tags: ['next js', 'tailwind']
draft: false
summary: '당근마켓을 모티브로 한 해외 거주 한인을 위한 중고거래 웹 서비스입니다. 워킹홀리데이 기간 동안 캐나다와 영국에서 실제 중고거래를 하며 겪은 불편함을 바탕으로, 해외에 거주하는 한인들이 보다 수월하고 안전하게 중고거래와 정보 교류를 할 수 있는 플랫폼을 직접 기획·개발했습니다.'
---

## | 해외 거주 한인 대상 중고거래 및 커뮤니티 플랫폼

#### 🗓️ 기간: 2025.03.24 ~

#### 🛠️ 사용 기술: HTML5, CSS, TailwindCSS, JavaScript, React.js, Next.js, Zustand, MongoDB, Firebase

#### 💐 번들링 도구: Webpack 5

#### 🌿 깃허브: [move to github](https://github.com/jyungx2/Next-urang-market)

#### 🖥️ 배포 도구: Vercel [move to site](https://next-urang-market.vercel.app/)

- **구현 방식** : Next.js(Page Router) 기반 SSG + SSR + CSR을 혼합 적용한 풀스택 플랫폼
- **프로젝트 개요** : 당근마켓을 모티브로 한 해외 거주 한인을 위한 중고거래 웹 서비스입니다.
  워킹홀리데이 기간 동안 직접 겪은 불편함을 바탕으로, 해외에 거주하는 한인들이 쉽고 안전하게 중고거래와 정보 교류를 할 수 있는 플랫폼을 직접 기획하고 개발했습니다.

  이 프로젝트는 다섯 개의 주요(또는 최상위) 페이지로 구성되어 있습니다.
  첫 번째는 홈페이지로, 공지사항·중고거래 검색 기능·커뮤니티 게시글을 섹션별로 한눈에 확인할 수 있도록 구성했습니다.

  `/market` 페이지에서는 사용자가 선택한 동네의 게시글만 노출되도록 지역코드를 활용한 필터링 기능을 구현했으며, 게시글 등록 시에는 위치 인증을 통해 본인이 실제로 있는 법정동(행정동)에 해당하는 지역에만 게시글을 올릴 수 있도록 제한했습니다.

  `/community` 페이지에서는 사용자가 ‘공지사항’, ‘해외살이’, ‘워킹홀리데이’, ‘해외취업’의 네 가지 주제 중 하나를 선택해 글을 작성하고 자신의 경험을 공유할 수 있으며, 댓글과 좋아요 기능도 함께 제공합니다.

  `/chat` 페이지에서는 중고물품 판매자와의 대화 기록이 담긴 채팅방 목록이 렌더링되고, 사용자는 채팅 상세 페이지에서 해당 상품을 바로 구매할 수 있습니다.

  마지막으로, 프로필 페이지에는 간단한 내비게이션 메뉴와 함께 위시리스트, 구매 내역 등의 사용자 활동 기록을 확인할 수 있으며, 로그아웃과 회원 탈퇴 기능도 제공합니다.

---

## 핵심 기능 구현

- **NextAuth.js + JWT 기반의 stateless 인증 구조 구현:**  
   사용자 정보 보호와 인증 상태 유지를 위해 JWT를 기반으로 한 세션/토큰 인증 흐름 설계 및 적용
- **Cloudinary API를 활용한 이미지 업로드 API 구축:**  
   프로필 및 게시글 이미지를 클라우드에 저장하고 secure URL을 반환하는 API 개발
  (\*base64 방식 대비 전송량 부담을 줄이고 확장성이 뛰어난 구조로 설계)
- **Tiptap 라이브러리를 활용한 커뮤니티 게시글 작성 및 등록 API 구현:**  
  ???
- **카카오 법정동 데이터를 MongoDB에 저장 및 검색 API 구현:**  
   사용자 입력에 따라 주소를 검색할 수 있는 API 및 연동 컴포넌트 개발 → **실시간 위치 검색 기능 제공**
- **브라우저 내장 Geolocation API + Kakao 역지오코딩 API 연동:**  
   현재 위치 좌표 기반으로 **법정동 주소 및 지역코드 자동 설정 기능** 구현
- **Redis + CoolSMS 기반 전화번호 인증 API 개발:**  
   CoolSMS API를 활용해 인증번호 발급(`/api/auth/send-code.js`) 및 검증(`/api/auth/verify-code.js`)로직을 구현하고, 로그인 절차와 연동  
   (\*추후 Firebase Authentication 기반 인증 시스템으로 전환 예정)
- **[Socket.io](http://Socket.io) 기반 실시간 채팅 기능 구현:**
  - 서버에 메시지가 저장되며 `_id`가 부여되기까지의 지연을 고려해, 프론트엔드에서는 `uuid`를 활용한 임시 `localId`를 생성해 UI에 즉시 반영함으로써 **UX 향상**
  - 이후 서버 응답으로 받은 메시지를 `localId` 기준으로 교체하여 최종 데이터와 동기화 처리  
    → 배포 완료 후, 구매자와 판매자 계정으로 동시 접속하여 실시간 채팅 정상 동작 테스트 예정

---

## Context 지역화와 Zustand 병행으로 UI 렌더링 최적화

사이드바·검색·설정·알림 같은 레이아웃 UI는 페이지마다 노출 조건이 달고 전역 동기화 대상이 아니므로, Zustand처럼 어디서든 접근 가능한 전역 스토어보다는 Provider 경계로 상태의 존재 범위를 명시적으로 구획할 수 있는 Context가 더 적합하다고 판단했습니다.

이에 전역 도메인 상태(로그인 유저, 선택 상품, 가입 단계)는 Zustand(selector) 로 관리해 부분 구독으로 리렌더 비용을 줄이고, 페이지 단위로만 필요한 UI 토글 상태는 \_app이 아니라 Layout 내부에 Provider를 두어 해당 레이아웃을 사용하는 서브트리로 스코프를 지역화했습니다.

그 결과, 해당 레이아웃을 사용하는 페이지에서만 상태가 존재·접근되고, 다른 레이아웃/페이지로 전환 시 자연스럽게 초기화되며, 전역 오염과 불필요한 전파를 차단할 수 있었습니다. 리팩토링은 메모이제이션으로 전파 빈도를 낮추고, 컨텍스트 분리로 전파 범위를 줄이는 방향으로 진행하였습니다.

### (1) useMemo/useCallback으로 불필요한 리렌더 억제

컨텍스트 업데이트는 React.memo를 우회하므로, Provider의 value 참조 안정화가 핵심입니다. 이를 위해 value 객체는 useMemo로, 토글 핸들러는 useCallback으로 각각 메모이제이션하여 참조가 불필요하게 바뀌지 않도록 했습니다. 그 결과, 부모가 다른 이유로 리렌더되더라도 실제 토글 값이 변하지 않는 한 컨텍스트 소비자에게 업데이트가 전파되지 않도록 억제했고, 토글 값이 변하는 순간에만 필요한 범위로 리렌더가 일어나도록 만들었습니다.

### (2) 기능별 Context로 업데이트 영향권 최소화

초기에는 모든 UI 토글을 단일 UIContext에서 관리했으나, 사이드바/검색/설정/알림을 개별 컨텍스트로 분리하는 리팩터링을 진행했습니다. 한 컨텍스트에 여러 플래그를 담아두면 그 중 하나만 바뀌어도 해당 컨텍스트의 모든 소비자가 리렌더되기 때문입니다. 컨텍스트를 기능별로 쪼개면 업데이트의 파급 범위가 필요한 부분으로만 제한되어, 예를 들어 사이드바 토글 시, 사이드바 관련 소비자만 리렌더되고 검색·설정·알림 영역은 영향을 받지 않도록 개선할 수 있었습니다. URL 기반으로 “어떤 UI를 보여줄지”를 제한하는 것(마운트/언마운트 제어)과, 마운트된 동안 리렌더 통지의 수신 대상을 줄이는 것(컨텍스트 분리)은 별개의 문제이며, 본 리팩터링은 후자에 초점을 맞췄습니다.

## 실시간 채팅 (WebSocket)

### (1) 로컬 임시 ID(localId)로 낙관적 렌더링

소켓 연결 수명(비싼 리소스)과 룸/리스너 수명(의존성 기반)을 \*\*useRef + 분리된 useEffect 로 나눠 조기 disconnect·중복 연결·중복 리스너를 제거했습니다. 연결은 마운트/언마운트 한 번만 생성/해제하고, 룸 전환 시에는 leaveRoom + on/off 만 처리하여 레이스 컨디션으로 인한 메시지 유실을 해소했습니다. 추가로 전송 전 연결확인/버퍼링과 localId 낙관적 렌더링을 결합해 체감 지연 0ms + 정합성을 동시에 달성했습니다.

### (2) 채팅 GET API 요청의 최신성을 보장하기 위해 조건부 요청 차단\*\*

브라우저는 기본적으로 GET 200 응답을 저장하고, 이후 동일 URL 호출 시 명시적 지시가 없으면 자동으로 조건부 요청(If-None-Match/If-Modified-Since) 흐름을 탑니다. 이때 서버·프록시가 반환한 304(Not Modified) 는 오류가 아니라 “재검증 성공 → 캐시 본문 재사용” 신호인데, 채팅처럼 쓰기 직후 읽기가 빈번하고(폴링/재연결/탭 전환), 동일 URL을 자주 두드리는 시나리오에선 이것이 최신성 결손을 초래할 수 있습니다. 이유는 검증자의 품질과 시각 정밀도(약한 ETag, Last-Modified 초 단위), 중간 프록시의 개입 등으로 실제 메시지가 늘어났어도 304가 과도하게 발생해 옛 본문을 재사용하는 일이 생기기 때문입니다.

이 문제를 제거하려고, 채팅·알림 등 실시간/개인화 API에는 Cache-Control: no-store 를 적용했습니다. no-store는 응답을 저장 자체를 금지하므로 검증자(ETag/Last-Modified)를 보유할 수 없고, 따라서 브라우저가 조건부 요청을 보낼 수 없습니다. 결과적으로 매 호출이 항상 200 + 최신 본문으로 귀결되어, 쓰기 직후 읽기 패턴에서도 UI가 일관된 최신 스냅샷을 받도록 보장했습니다.

---

## 트러블슈팅

**🔹 유저의 좋아요/싫어요 여부가 포함된 목록 렌더링 시, 시간복잡도를 고려한 데이터 구조 선택**

### 📌 구현 배경 및 해결 전략

중고마켓 커뮤니티 목록과 중고물품 목록에서, 각 게시글에 대해 사용자가 “좋아요/싫어요”를 눌렀는지 또는 위시리스트에 추가했는지를 판별해야 했습니다.
이를 위해 초기에는 API Routes에서 게시글 목록을 불러온 뒤, 유저의 likes, dislikes, wishlist 배열을 순회하며 includes() 메소드를 사용해 해당 게시글의 ID가 포함되어 있는지를 매번 확인하는 방식으로 구현하였습니다.

```js:api/posts/index.js
// 좋아요/싫어요 "배열" 생성
const likesArr = (user.likes ?? []).map(String);
const dislikesArr = (user.dislikes ?? []).map(String);

// 게시글에 userHasLiked / userHasDisliked 계산해서 붙이기
const postsWithUserStatus = documents.map((post) => {
  const id = String(post._id);
  return {
    ...post,
    userHasLiked: likesArr.includes(id),       // O(L)
    userHasDisliked: dislikesArr.includes(id), // O(L)
  };
});
```

### 📌 어떤 고민이 있었는지?

이 방식은 소규모 데이터에서는 문제없이 동작했으나, 데이터가 많아질수록 성능 저하가 두드러졌습니다. 실제로 게시글과 사용자 데이터가 일정 규모를 넘어가자 목록 API 응답 지연과 클라이언트 렌더링 지연이 동시에 발생하였고, 체감 속도가 눈에 띄게 떨어졌습니다.

문제의 원인을 살펴보니, 배열에서 “includes()”를 사용할 경우 특정 요소가 존재하는지를 확인하기 위해 매번 배열의 처음부터 끝까지 순차 탐색을 수행하게 되어 시간복잡도가 O(n)에 해당한다는 점이 성능 저하의 핵심 요인이었습니다.

### 📌 어떻게 해결했는지?

문제를 해결하기 위해 자료구조의 선택이 성능에 큰 영향을 준다는 점에 주목했습니다.

시간복잡도를 표현할 때에는 일반적으로 빅 오 표기법(Big O notation)을 사용하는데, 이는 입력 크기 *n*이 무한히 커질 때 실행 시간이 증가하는 추세를 점근적 상한으로 나타낸 것입니다.

여기서 **점근적 상한**이란, 입력하는 n이 무한대로 커진다고 생각했을 때, 일반적으로 n에 따라 실행시간도 점점 계속해서 증가할 것입니다. 하지만 **실행시간이 증가하는 데에도 한계**가 있는데, 이 한계를 **_점근적 상한이라고 부릅니다._** 즉, 실제 실행 시간이 경우에 따라 조금 더 빠를 수도 있지만, 최악의 경우를 기준으로 했을 때 반드시 넘지 못하는 시간 증가의 한계선을 수학적으로 표현한 개념입니다.

배열에서 `includes()` 메소드를 사용할 경우, 특정 데이터의 존재 여부를 확인하기 위해 앞에서부터 끝까지 순차적으로 탐색해야 합니다. 이때 최악의 경우에는 n개의 요소를 모두 검사해야 하므로, 실행 시간은 입력 크기 n에 비례하여 증가하게 됩니다. 이러한 성능을 빅 오 표기법(점근적 상한)으로 표현하면 **O(n)**, 즉 선형시간 복잡도를 갖습니다.

반면 `Set`은 내부적으로 해시테이블을 기반으로 동작합니다. 해시 함수가 곧바로 해당 요소의 주소를 찾아가기 때문에, 입력 크기와 상관없이 일정한 시간 내에 탐색이 가능합니다. 이러한 경우 실행 시간은 데이터가 아무리 많아져도 일정한 상한에 머물게 되고, 이를 빅 오 표기법으로 표현하면 **O(1)**, 즉 상수시간 복잡도를 갖습니다.

다시 말해 배열은 원하는 인덱스를 알고 있을 때는 O(1)로 접근할 수 있지만, 특정 데이터의 존재 여부를 확인하는 연산에서는 O(n)의 시간복잡도를 가집니다. 반면 `Set`은 내부적으로 해시테이블 기반으로 구현되어 있어, 요소의 존재 여부를 확인하는 연산에서 기대 시간복잡도가 O(1)에 해당합니다.

따라서, 유저의 `likes`, `dislikes`, `wishlist` 배열을 API 응답 단계에서 모두 `Set`으로 변환한 뒤, 각 게시글에 대해 `set.has(id)`로 존재 여부를 확인하도록 리팩토링하였습니다. 그 결과, 데이터가 많아져도 일정한 속도로 결과를 반환할 수 있었고, API 응답 지연과 클라이언트 렌더링 지연 문제를 동시에 해소할 수 있었습니다.

- `Array.prototype.includes()` → **O(n)**: 배열을 앞에서부터 끝까지 훑음
- `Set.prototype.has()` → **O(1)** 기대: 해시 조회(주소 찾아가기)에 해당'

```js:api/posts/index.js
// 좋아요/싫어요 Set 생성
const likeSet = new Set((user.likes ?? []).map(String));
const dislikeSet = new Set((user.dislikes ?? []).map(String));

// 각 게시글에 userHasLiked / userHasDisliked 계산해서 붙이기
const postsWithUserStatus = documents.map((post) => {
  const id = String(post._id);
  return {
    ...post,
    userHasLiked: likeSet.has(id),       // O(1) 기대
    userHasDisliked: dislikeSet.has(id), // O(1) 기대
  };
});
```

### 📌 무엇을 배웠는지?

- 시간복잡도의 개념과 이를 빅 오(Big O) 표기법으로 나타내는 방법을 명확히 이해했습니다.
- 배열과 Set의 시간복잡도를 비교하며, **특정 데이터의 존재 여부를 확인하는 연산에는 Set이 훨씬 효율적**임을 학습했습니다.
- 해시테이블 기반 자료구조는 속도가 빠른 만큼 메모리 공간을 더 많이 차지하긴 하지만, 순차 탐색을 수행하는 배열보다 일반적으로 우수한 성능을 제공한다는 점을 확인했습니다.
- 기능을 구현할 때는 단순히 동작 가능 여부뿐 아니라, 데이터 규모가 커졌을 때의 성능까지 고려하여 **자료구조를 적절히 선택하는 것이 중요**하다는 점을 배웠습니다.

### 현재 미구현 기능 (추후 개발 예정)

- 로그인 시 국가 설정 기능
- 메인 홈 페이지 UI 및 콘텐츠 구성
- 알림 기능
- 회원가입/로그인 시 인증 방식 리팩토링 예정
