---
title: ‘다시봄’
date: '2024-12-20'
tags: ['next js', 'tailwind']
draft: false
summary: The Time Traveller (for so it will be convenient to speak of him) was
  expounding a recondite matter to us. His pale grey eyes shone and
  twinkled, and his usually pale face was flushed and animated...
---

## | 친환경 제품을 판매하는 이커머스 플랫폼

**🗓️ 기간:** 2024.12.16 ~ 2024.01.24  
**👥 팀 구성:** 프론트엔드 개발자 5인  
**👩‍💻 담당 역할:** 프론트엔드 개발 / 회원관리 기능 전담  
**🛠️ 사용 기술:** HTML5, CSS3, TailwindCSS, JavaScript, React, Zustand  
**💐 번들링 도구:** Vite

- **구현 방식** : React 기반 CSR 방식의 전형적인 쇼핑몰 구조
- **프로젝트 개요** : 친환경 제품 전문 쇼핑몰 ‘자연상점’을 참고하여 제작한 ‘다시봄’은 지속 가능한 소비를 촉진하고, 다시 지구에 봄이 오길 바라는 마음을 담아 이름 지은 친환경 쇼핑몰 웹사이트입니다. 전형적인 이커머스 플랫폼의 구조를 바탕으로, 상품 목록 조회, 상세 페이지, 장바구니, 주문/결제, 찜하기, 후기/Q&A 등 기본적인 쇼핑몰 기능을 충실히 구현하였으며, React, Zustand, React Query, Tailwind CSS 등 최신 프론트엔드 기술 스택을 활용해 효율적인 상태 관리와 사용자 경험에 초점을 맞추었습니다.

**🌿 깃허브:** [move to github](https://github.com/jyungx2/againSpring_refactor)  
**🖥️ 배포 도구:** Netlify [move to site](https://main--2trillionmarket.netlify.app/)

---

## 기여 내용

- 이메일·비밀번호 로그인과 카카오 OAuth 2.0 로그인 구현으로 인증 방식 다변화
- JWT 기반 액세스·리프레시 토큰 구조 적용 및 axios 인터셉터로 자동 토큰 갱신 처리
- Zustand의 `persist.setOptions()`로 autoLogin 여부에 따른 스토리지 분기 처리 구현
- 전역 Tailwind 설정(`tailwind.config.js`)을 통한 폰트·컬러 시스템 정의 및 UI 일관성 확보
- Vite 내 경로 alias(`@components`, `@hooks` 등) 설정으로 유지보수성 및 협업 효율 향상
- 인증되지 않은 사용자를 차단하는 `ProtectedRoutes` 컴포넌트 구현으로 보안성 강화
- Zustand 기반 장바구니 로직을 React Query로 리팩토링하여 데이터 캐싱 및 구조 최적화
- PortOne 결제 API 연동을 통해 이니시스, 카카오페이 등 다양한 결제 수단을 지원하는 결제 기능 구현

---

## 트러블슈팅

### 📌 구현 배경 및 해결 전략

보안에 민감한 요즘, 사용자 인증 정보를 **세션 스토리지에 저장해 브라우저 종료 시 삭제**하는 방식이 선호됩니다. 하지만 사용자가 자주 방문하는 사이트라면, **자동로그인을 원하는 경우도 많기 때문에**, 사용자의 선택에 따라 로그인 정보를 유지할 수 있도록 **스토리지를 동적으로 선택**하는 기능이 필요했습니다.

자동로그인 체크 여부에 따라 로컬스토리지 또는 세션스토리지 중 **적절한 스토리지에 사용자 정보를 저장**하는 구조를 전역 상태 라이브러리인 zustand을 활용해 구현하고자 했습니다.

### 📌 어떤 고민이 있었는지?

자동로그인 기능을 체크한 경우에는 **브라우저를 닫아도 로그인 유지**, 끈 경우에는 **새 창에서 다시 로그인**하도록 설계해야 했습니다.

하지만 `zustand`의 `persist` 미들웨어는 **초기 설정 시 스토리지를 고정**해야 해서, `autoLogin` 상태값에 따라 런타임에 **스토리지를 전환하는 기능이 부족**했습니다. 이 문제를 해결하려면, `persist` 외에 추가적인 기능이 필요했습니다.

### 📌 어떻게 해결했는지?

공식문서를 참고해, persist 미들웨어의 setOptions API를 활용하여 문제를 해결할 수 있었습니다.

persist 미들웨어에서 제공하는 다양한 옵션 중 하나인 setOptions는 스토리지 엔진 자체를 런타임 중 동적으로 바꿀 수 있는 API 입니다. persist 미들웨어는 다양한 추가 옵션들을 제공하는데, 그 중 자동로그인 기능 구현에 완벽하게 부합했던 것이 바로 이 setOptions였습니다.

최종적으로 아래의 코드를 추가해 기능을 구현했습니다. 사용자가 로그인할 때 user 객체에 포함된 autoLogin 값을 기준으로, true일 경우 로컬스토리지를, false일 경우엔 세션스토리지를 반환하도록 하였고, 이를 통해 새로고침이나 페이지 이동시에도 아래 Persist 함수를 통해 다시 autoLogin값을 불러와 유저 정보를 자동으로 복원시킬 수 있었습니다.

### 📌 무엇을 배웠는지?

- zustand로 전역 상태를 관리할 때는 persist 미들웨어가 필수적이라는 것입니다. persist를 사용해야만 페이지 새로고침이나 이동 시에도 중복되는 `useEffect()` 코드 없이, 상태값이 항상 안정적으로 유지되기 때문입니다.
- zustand 미들웨어가 제공하는 다양한 옵션이나 API 함수를 활용하면 더욱 섬세한 상태 관리가 가능하다는 것입니다. 특히 자동 로그인처럼 동적인 스토리지 전환이 필요한 경우, `setOptions`라는 API를 활용하면 코드의 일관성과 유연성을 모두 확보할 수 있다는 사실을 배웠습니다.
